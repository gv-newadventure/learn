Great—here’s exactly what you asked for: a **global claim** stored procedure that returns the rows you need for `ClaimedWorkItem` (one row per document, including the `RemapID`), plus the **repository method** that calls it and maps to your `ClaimedWorkItem` type.

---

# 1) SQL: Global claim across RemapIDs (randomized), with logging & backup

This version:

* Takes **only** `@BatchSize` (no SiteCode parameter).
* Selects documents **across many RemapIDs** whose **master status is READY**.
* Ensures **tenant safety** by joining on `SiteCode` (assuming both tables have it).
* **Seeds the migration log** (PROCESSING) and **backs up** the current XML in one shot.
* Returns exactly the two columns you need: **`RemapID`, `DocumentKey`** (your `ClaimedWorkItem`).

```sql
CREATE OR ALTER PROC dbo.usp_Remap_ClaimNextGlobalBatch
    @BatchSize INT
AS
BEGIN
    SET NOCOUNT ON;

    /* Pick a randomized global batch across many remaps */
    ;WITH ToClaim AS
    (
        SELECT TOP (@BatchSize)
               r.RemapID,
               dk.DocumentKey
        FROM dbo.tbl_IMG_DocumentCategoryRemap            AS r   WITH (READPAST)
        JOIN dbo.tbl_IMG_DocumentKeys                     AS dk  WITH (READPAST)
             ON dk.CategoryKey = r.SourceCategoryKey
            AND dk.SiteCode    = r.SiteCode               -- tenant safety
        WHERE r.Status = 'READY'
          AND NOT EXISTS
              ( SELECT 1
                FROM dbo.tbl_IMG_DocumentCategoryRemapMigrationLog AS ml
                WHERE ml.RemapID    = r.RemapID
                  AND ml.DocumentKey = dk.DocumentKey )
        ORDER BY NEWID()   -- randomize so multiple remaps get progress concurrently
    )
    /* Seed log rows (PROCESSING) and back up current XML */
    INSERT dbo.tbl_IMG_DocumentCategoryRemapMigrationLog
          (RemapID, DocumentKey, FieldDataBeforeMigration, Status, ModifiedBy, ModifiedOn)
    SELECT t.RemapID,
           t.DocumentKey,
           dd.FieldData,
           'PROCESSING',
           SUSER_SNAME(),
           SYSUTCDATETIME()
    FROM ToClaim t
    JOIN dbo.tbl_IMG_DocumentData AS dd
         ON dd.DocumentKey = t.DocumentKey;

    /* Return exactly what the worker needs for ClaimedWorkItem */
    SELECT RemapID, DocumentKey
    FROM ToClaim;
END
GO
```

> If **`SiteCode`** is not present on one of the tables, drop that join predicate. If you store tenant on a different table, move the predicate accordingly—the key is: **the SP enforces tenant alignment internally**, while still taking **only** `@BatchSize`.

---

# 2) Core model: `ClaimedWorkItem`

Place this in **Remap.Core/Models/ClaimedWorkItem.cs**:

```csharp
namespace Remap.Core.Models;

public sealed record ClaimedWorkItem(int RemapId, Guid DocumentKey);
```

---

# 3) Repository method: `ClaimNextGlobalBatchAsync`

Add this to your existing **`SqlRemapRepository`** (in **Remap.Infrastructure**).
This calls the new SP and maps the resultset into `List<ClaimedWorkItem>`.

```csharp
using System.Data;
using Microsoft.Data.SqlClient;
using Microsoft.Extensions.Options;
using Microsoft.Extensions.Logging;
using Remap.Core.Models;
using Remap.Core.Abstractions;

namespace Remap.Infrastructure.Data
{
    public sealed partial class SqlRemapRepository : IRemapRepository
    {
        // ... existing fields/ctor ...

        public async Task<IReadOnlyList<ClaimedWorkItem>> ClaimNextGlobalBatchAsync(int batchSize, CancellationToken ct)
        {
            var items = new List<ClaimedWorkItem>(capacity: batchSize);

            await using var con = new SqlConnection(_cs);
            await con.OpenAsync(ct);

            using var cmd = new SqlCommand("dbo.usp_Remap_ClaimNextGlobalBatch", con)
            {
                CommandType = CommandType.StoredProcedure,
                CommandTimeout = _timeout
            };
            cmd.Parameters.AddWithValue("@BatchSize", batchSize);

            using var rdr = await cmd.ExecuteReaderAsync(ct);
            while (await rdr.ReadAsync(ct))
            {
                // Resultset: RemapID (int), DocumentKey (uniqueidentifier)
                int remapId    = rdr.GetInt32(0);
                Guid docKey    = rdr.GetGuid(1);
                items.Add(new ClaimedWorkItem(remapId, docKey));
            }

            return items;
        }
    }
}
```

> If your `IRemapRepository` didn’t have this yet, add to the interface in **Remap.Core/Abstractions/IRemapRepository.cs**:

```csharp
Task<IReadOnlyList<ClaimedWorkItem>> ClaimNextGlobalBatchAsync(int batchSize, CancellationToken ct);
```

---

## How you’ll use it (context)

* Call `ClaimNextGlobalBatchAsync(batchSize)` once per **global cycle**.
* You’ll receive a **flat list** of mixed work (many `RemapID`s).
* **Do not** group by `RemapID`.
  Instead, **shard by parallelism** (e.g., 1000 batch, parallelism 4 ⇒ 4 shards of ~250).
  Each shard independently:

  1. fetches the docs’ XML for its keys,
  2. transforms,
  3. **applies once** (one `ApplyBatchAsync` call) for that shard.

That satisfies your requirement: **no RemapID iteration**, **multi-tenant safety**, and **only 4 DB writes** for a 1000-size batch with parallelism 4.
